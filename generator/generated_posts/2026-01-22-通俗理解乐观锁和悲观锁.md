---
layout:     post
title:      "通俗理解乐观锁和悲观锁"
subtitle:   "归档于：面经"
date:       2026-01-22
author:     Chieh
header-img: assets/通俗理解乐观锁和悲观锁_header.jpg
catalog: true
tags:
    - Interview
    - JAVA
    - 面经
---

### **乐观锁**

      每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。一般使用version方式和CAS操作方式。

**Version方式：**

        一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

```
核心SQL代码：update table set x=x+1, version=version+1 where id=#{id} and version=#{version};
```


**CAS操作方式：**

        即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。

---

**乐观锁使用场景**

     比较适合**读取操作比较频繁的场景**，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。

---

**悲观锁**

每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。在Java中，synchronized的思想也是悲观锁。

---

**悲观锁使用场景**

比较适合**写入操作比较频繁的场景**，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。

---
> 参考链接：[https://www.cnblogs.com/xinruyi/p/11537787.html](https://www.cnblogs.com/xinruyi/p/11537787.html)
