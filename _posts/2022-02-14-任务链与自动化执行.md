---
layout:     post
title:      如何构建一条任务链？
subtitle:   Java中的自动任务执行
date:       2022-02-14
author:     Chieh
header-img: https://logos-marques.com/wp-content/uploads/2021/03/Java-Logo-histoire.jpg
catalog: true
tags:
    - Programming
    - Java
    - SpringMVC
    - AOP
    - HTTP
---

## 前言

自动任务执行十分实用————前提是弄懂了执行的优先级，且不会犯低级错误。

## 任务链

### 想法

任务链解释起来很简单，无非是一环套一环

### 实现方式（1）

为了实现自动化执行，一个调用一个的方式看起来很简单，也很符合常理。

但如果单纯只考虑执行，而不考虑执行顺序，我们可以直接采用Spring托管的方式，让Spring帮我们托管要执行的方法————直接在@Configuration注解方法中执行操作也是可行的。

如果要强调先后顺序，可以在@Configuration中规定依赖来判断特定的先后顺序，也可以采用@Order注解来手动判断优先级————不过这样太蠢了。

顺便一提，Spring有时候对于继承自统一父类的多种方法貌似不能很好地进行Bean的托管。

### 实现方式（2）

如果要更优雅一点，我们可以考虑采用一个register，以及一个依赖于Spring的自动执行方法。

首先声明一个虚拟的父类，以便将它们都放入一个list。

其次实现一个执行器，对任务列表进行顺序执行。一般这种方式适用于在操作前后都需要执行preHandle以及postHandle方法集合的情况。

————需要对被插入操作的方法进行修改。

在初始化时对所有继承自同一父类的不同方法进行注册，并在需要自动化执行时顺序执行即可。这样还可以使不同的方法共享某些资源，减少重复操作。

### 实现方式（3）

接下来两个方法都和某些非自动执行，而是需要在调用时执行的方法有关。

首先是SpringMVC提供的AOP方法：[SpringMVC与AOP](./2022-02-14-SpringMVC与AOP.md)

————不需要对被插入操作的方法进行修改。

它通过对接口进行拦截，在方法上添加注解@Aspect以及@Component，在进入某些接口附近添加@Pointcut注解，就可以在其附近拿到请求参数了。

下面是一个标准的AOP切面配置示例。它定义了一个切点（Pointcut），并使用环绕通知（Around）来处理逻辑：

```java
@Aspect
@Component
public class RequestAspect {

    // 定义切点，例如拦截 controller 包下的所有方法
    @Pointcut("execution(* com.chieh.controller..*.*(..))")
    public void pointCut() {}

    @Around("pointCut()")
    public Object around(ProceedingJoinPoint jp) throws Throwable {
        // 1. 获取方法参数
        Object[] args = jp.getArgs();
        
        // 此处可以插入前置任务逻辑
        System.out.println("AOP: Before execution");

        // 2. 执行原方法
        Object result = jp.proceed();

        // 此处可以插入后置任务逻辑
        System.out.println("AOP: After execution");

        return result;
    }
}
```

通过拿到的ProceedingJoinPoint对象，我们可以拿到它的参数args[]数组（仅仅依靠类型区分，可能需要遍历来判断）

在执行结束后，我们需要重新回调原接口————直接用ProceedingJoinPoint的proceed()方法就好，你甚至可以把返回参数挂起，再执行之后的操作。

当然，try...finally的后者是必定执行的，即使前面有return操作，大可放心。

这一点可以看这个[Finally的执行时机](./2022-02-14-Finally的执行时机.md)

### 实现方式（4）

这种方法是在请求之前执行，获得的数据为整个Http请求。

根据实际的请求参数不同，它实际上可以拿到RequestBody、RequestHeader等，进行一次格式转化即可使用。或者使用RequestContent，不过貌似只能拿到请求头，而非请求体。

————也不需要对被插入操作的方法进行修改。

他也需要在注册时对自己所拦截的接口进行说明，并依赖一条任务链顺序执行。

在Spring Boot中，通常通过实现 `WebMvcConfigurer` 接口来注册拦截器：

```java
@Configuration
public class WebAppConfig implements WebMvcConfigurer {

    @Autowired
    private MyCustomInterceptor myCustomInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 注册拦截器，并设置拦截路径
        registry.addInterceptor(myCustomInterceptor)
                .addPathPatterns("/**")  // 拦截所有请求
                .excludePathPatterns("/login", "/static/**"); // 排除特定路径
    }
}
```

顺便一提，在获取HttpServletRequest的数据流后，下一条任务以及接口本身的request就清空了————所以需要手动给request重新赋值，挺蠢的。

这是因为 `HttpServletRequest` 中的 `InputStream` 是一次性流（One-time use）。

1.  **ServletInputStream**：这是最底层的流，当我们在拦截器或过滤器中调用 `request.getInputStream()` 或 `request.getReader()` 读取了Body内容后，流的指针就指向了末尾。
2.  **Controller中的读取**：当请求到达Controller时，SpringMVC尝试再次读取Body来绑定参数（如 `@RequestBody`），发现流已经读完了，就会抛出 "Required request body is missing" 异常。

**解决方案**：
需要使用 **Request Wrapper** 模式。我们可以继承 `HttpServletRequestWrapper`，将读取到的Body字节缓存在一个 `byte[]` 数组中。并在重写的 `getInputStream()` 方法中，每次都返回一个新的、基于该字节数组的 `ByteArrayInputStream`。

Spring 提供了一个现成的实现：`ContentCachingRequestWrapper`，但要注意它通常需要在 Filter 链中尽早包装，且在使用时可能需要显式调用 `getContentAsByteArray()`。